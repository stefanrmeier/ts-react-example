// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/7aaf957deb409060efc12dcafa001708f677cbb5/redux-form/lib/reduxForm.d.ts
declare module '~redux-form/lib/reduxForm' {
import {
    Component,
    ReactElement,
    SyntheticEvent,
    ReactEventHandler,
} from 'react';
import { Dispatch } from 'redux';
import { DataShape, FieldValue, FormErrors, FormWarnings, RegisteredFieldState } from '~redux-form/index';

export function reduxForm<FormData extends DataShape, P, S>(
    config: Config<FormData, P, S>
): FormDecorator<FormData, P, S>;

export function reduxForm<FormData extends DataShape, P>(
    config: Config<FormData, P, any>
): FormDecorator<FormData, P, any>;

export function reduxForm(
    config: Config<any, any, any>
): FormDecorator<any, any, any>;

export interface FormDecorator<FormData extends DataShape, P, S> {
    <T extends (typeof Component)>(component: T): T & Form<FormData, P, S>;
}

export interface Config<FormData extends DataShape, P, S> {
    /**
     * the name of your form and the key to where your form's state will be
     * mounted under the redux-form reducer
     */
    form: string;

    /**
     * An adapter function that will render a component based on a string component
     * type and the props given to a Field. Remember that all you really need to hook
     * up to your custom component's value and onChange. Defaults to [].
     *
     * See Asynchronous Blur Validation Example for more details.
     */
    adapter?: (component: string, props: Object) => ReactElement<any>;

    /**
     * field names for which onBlur should trigger a call to the asyncValidate
     * function. Defaults to [].
     *
     * See Asynchronous Blur Validation Example for more details.
     */
    asyncBlurFields?: string[];

    /**
     * a function that takes all the form values, the dispatch function,
     * the props given to your component and the current blurred field,
     * and returns a Promise that will resolve if the validation is passed,
     * or will reject with an object of validation errors in the form { field1: <String>, field2: <String> }.
     *
     * See Asynchronous Blur Validation Example for more details.
     */
    asyncValidate?(values: FormData, dispatch: Dispatch<S>, props: P, blurredField: string): Promise<any>;

    /**
     * Whether or not to automatically destroy your form's state in the Redux
     * store when your component is unmounted. Defaults to true.
     */
    destroyOnUnmount?: boolean;

    /**
     * A function that takes the entire Redux state and returns the state slice
     * which corresponds to where the redux-form reducer was mounted. This
     * functionality is rarely needed, and defaults to assuming that the reducer
     * is mounted under the "form" key.
     */
    getFormState?(state: S): any;

    /**
     * When set to true and enableReinitialize is also set, the form will retain the value of dirty fields when
     * reinitializing. When this option is not set (the default), reinitializing the form replaces all field values.
     * This option is useful in situations where the form has live updates or continues to be editable after
     * form submission; it prevents reinitialization from overwriting user changes. Defaults to false.
     */
    keepDirtyOnReinitialize?: boolean;

    /**
     * If true, implements `shouldComponentUpdate` and shallowly compares _only_
     * the Redux-connected props that are needed to manage the form state. This
     * prevents unnecessary updates, but assumes the component is a "pure"
     * component and does not rely on any input or state other than its props and
     * the selected Redux store's state. Defaults to true.
     */
    pure?: boolean;

    /**
     * The values with which to initialize your form in componentWillMount().
     * Particularly useful when Editing Multiple Records, but can also be used
     * with single-record forms. The values should be in the form
     * { field1: 'value1', field2: 'value2' }.
     */
    initialValues?: FormData;

    /**
     * Reinitialize the form every time the initialValues prop changes.
     * Defaults to false.
     */
    enableReinitialize?: boolean;

    /**
     * The function to call with the form data when the handleSubmit() is fired
     * from within the form component. If you do not specify it as a prop here,
     * you must pass it as a parameter to handleSubmit() inside your form
     * component.
     */
    onSubmit?: SubmitHandler<FormData, P, S>;

    /**
     * A callback function that will be called when a submission fails for whatever reason.
     *
     * @param errors      The errors that caused the submission to fail.
     * @param dispatch    The Redux `dispatch` function.
     * @param submitError The error object that caused the submission to fail. If `errors` is set this will be most
     *                    likely a `SubmissionError`, otherwise it can be any error or null.
     */
    onSubmitFail?(errors: FormErrors<FormData>, dispatch: Dispatch<S>, submitError: any): void;

    /**
     * A callback function that will be called when a submission succeeds.
     */
    onSubmitSuccess?(result: any, dispatch: Dispatch<S>, props: any): void;

    /**
     * Do not remove submit errors when the change action is fired. Defaults to false.
     */
    persistentSubmitErrors?: boolean;

    /**
     * If specified, all the props normally passed into your decorated
     * component directly will be passed under the key specified. Useful if
     * using other decorator libraries on the same component to avoid prop
     * namespace collisions.
     */
    propNamespace?: string;

    /**
     * The use of this property is highly discouraged, but if you absolutely
     * need to mount your redux-form reducer at somewhere other than form in
     * your Redux state, you will need to specify the key you mounted it under
     * with this property. Defaults to 'form'.
     *
     * See Alternate Mount Point Example for more details.
     */
    reduxMountPoint?: string;

    /**
     * An optional function you may provide to have full control over when sync validation happens.
     */
    shouldValidate?(params: ValidateCallback<FormData>): boolean;

    /**
     * An optional function you may provide to have full control over when async
     * validation happens.
     */
    shouldAsyncValidate?(params: AsyncValidateCallback<FormData>): boolean;

    /**
     * marks fields as touched when the blur action is fired. Defaults to true.
     */
    touchOnBlur?: boolean;

    /**
     * marks fields as touched when the change action is fired. Defaults to
     * false.
     */
    touchOnChange?: boolean;

    /**
     * a synchronous validation function that takes the form values and props
     * passed into your component. If validation passes, it should return {}.
     * If validation fails, it should return the validation errors in the form
     * { field1: <String>, field2: <String> }.
     * Defaults to (values, props) => ({}).
     */
    validate?(values: FormData, props: FormProps<FormData, P, S> & P): FormErrors<FormData>;

    /**
     * A synchronous warning function that takes the form values and props passed into your component.
     * Warnings work the same as validations, but do not mark a form as invalid. If the warning check passes,
     * it should return {}. If the check fails, it should return the warnings in the form
     * { field1: <String>, field2: <String> }. Defaults to (values, props) => ({}).
     */
    warn?(values: FormData, props: FormProps<FormData, P, S> & P): FormWarnings<FormData>;
}

/**
 * If your onSubmit function returns a promise, the submitting property will be set to true
 * until the promise has been resolved or rejected. If it is rejected with a redux-form
 * SubmissionError containing errors in the form { field1: 'error', field2: 'error' } then
 * the submission errors will be added to each field (to the error prop) just like async
 * validation errors are. If there is an error that is not specific to any field, but applicable
 * to the entire form, you may pass that as if it were the error for a field called _error,
 * and it will be given as the error prop.
 */
export interface SubmitHandler<FormData extends DataShape, P, S> {
    (values: FormData, dispatch: Dispatch<S>, props: FormProps<FormData, P, S> & P): void | FormErrors<FormData> | Promise<any>;
}

interface ValidateCallback<FormData extends DataShape> {
    /**
     * The values.
     */
    values: FormData;

    /**
     * The next props.
     */
    nextProps: Object;

    /**
     * The current props.
     */
    props: Object;

    /**
     * true if the form is being initially rendered.
     */
    initialRender: boolean;

    /**
     * The structure object being used internally for values. You may wish to use 'deepEqual' from the structure.
     */
    structure: Object;
}

interface AsyncValidateCallback<FormData extends DataShape> {
    /**
     * Any existing asynchronous validation errors
     */
    asyncErrors?: FormErrors<FormData>;

    /**
     * true if the form has ever been initialized with initial values
     */
    initialized: boolean;

    /**
     * The reason to possibly run async validation. It will either be: 'blur' or
     * 'submit', depending on whether an async blur field had triggered the async
     * validation or if submitting the form has triggered it, respectively.
     */
    trigger: 'blur' | 'submit';

    /**
     * The name of the field that has triggered the async validation. May be undefined.
     */
    blurredField?: string;

    /**
     * true if the form is pristine, false if it is dirty
     */
    pristine: boolean;

    /**
     * true if synchronous validation is passing, false if it is failing.
     */
    syncValidationPasses: boolean;
}

/**
 * A throwable error that is used to return submit validation errors from onSubmit.
 * The purpose being to distinguish promise rejection because of validation errors
 * from promise rejection because of AJAX I/O problems or other server errors.
 */
export class SubmissionError<FormData extends DataShape> extends Error {
    errors: FormErrors<FormData>;

    constructor(errors?: FormErrors<FormData>);
}

/**
 * The following are methods or properties that you can access on an instance
 * of your decorated form component (outermost component named "ReduxForm").
 */
export interface Form<FormData extends DataShape, P, S> extends Component<P, any> {
    /**
     * true if the form data has changed from its initialized values. Opposite
     * of pristine.
     */
    dirty: boolean;

    /**
     * true if the form has validation errors. Opposite of valid.
     */
    invalid: boolean;

    /**
     * true if the form data is the same as its initialized values. Opposite
     * of dirty.
     */
    pristine: boolean;

    /**
     * An array of objects with fields `name` and `type` for each field
     * representing all the fields in the form. Mainly useful for testing.
     */
    registeredFields: RegisteredFieldState[];

    /**
     * Resets all the values in the form to the initialized state, making it
     * pristine again.
     */
    reset(): void;

    /**
     * Submits the form. Returns a promise that will be resolved when the form
     * is submitted successfully, or rejected if the submission fails.
     */
    submit(): Promise<any>;

    /**
     * true if the form passes validation (has no validation errors). Opposite
     * of invalid.
     */
    valid: boolean;

    /**
     * The current values of all the fields in the form.
     */
    values: FormData;

    /**
     * A reference to the instance of the component you decorated with reduxForm().
     * Mainly useful for testing.
     */
    wrappedInstance: ReactElement<P & FormProps<FormData, P, S>>
}

/**
 * These are the props that will be passed to your form component.
 * Your form component's props can extend this interface.
 */
export interface FormProps<FormData extends DataShape, P, S> {
    /**
     * true if any of the fields have been marked as touched, false otherwise.
     */
    anyTouched?: boolean;

    /**
     * A set of pre-bound action creators for you to operate on array fields in your form.
     */
    array?: {
        /**
         * Inserts a value into the given array field in your form.
         */
        insert(field: string, index: number, value: FieldValue): void;

        /**
         * Moves a value at the given from index to the given to index in
         * the given array field in your form.
         */
        move(field: string, from: number, to: number): void;

        /**
         * Pops a value off of the end of a given array field in your form.
         */
        pop(field: string): void;

        /**
         * Pushes the given value onto the end of the given array field in your form.
         */
        push(field: string, value: FieldValue): void;

        /**
         * Removes a value at the given index from the given array field in your form.
         */
        remove(field: string, index: number): void;

        /**
         * Removes all the values from the given array field in your form.
         */
        removeAll(field: string): void;

        /**
         * Shifts a value out of the beginning of the given array in your form.
         */
        shift(field: string): void;

        /**
         * Performs an Array.splice operation on the given array in your form.
         */
        splice(field: string, index: number, removeNum: number, value: FieldValue): void;

        /**
         * Swaps two values at the given indexes of the given array field in your form.
         */
        swap(field: string, indexA: number, indexB: number): void;

        /**
         * Unshifts the given value into the beginning of the given array field in your form.
         */
        unshift(field: string, value: FieldValue): void;
    }

    /**
     * A function that may be called to initiate asynchronous validation if
     * asynchronous validation is enabled.
     */
    asyncValidate?: () => void;

    /**
     * This value will be either:
     * - false - No asynchronous validation is currently happening
     * - true - Asynchronous validation is currently running in preparation to submit a form
     * - a string - The name of the field that just blurred to trigger asynchronous validation
     */
    asyncValidating?: string | boolean;

    /**
     * Sets the value and marks the field as autofilled in the Redux Store. This is useful when a field
     * needs to be set programmatically, but in a way that lets the user know (via a styling change using
     * the autofilled prop in Field) that it has been autofilled for them programmatically.
     */
    autofill?(field: string, value: FieldValue): void;

    /**
     * Marks a field as blurred in the Redux store.
     */
    blur?(field: string, value: FieldValue): void;

    /**
     * Changes the value of a field in the Redux store.
     */
    change?(field: string, value: FieldValue): void;

    /**
     * Clear async error of a field in the Redux store.
     */
    clearAsyncError?(field: string): void;

    /**
     * Destroys the form state in the Redux store. By default, this will be
     * called for you in componentWillUnmount().
     */
    destroy?(): void;

    /**
     * true if the form data has changed from its initialized values. Opposite
     * of pristine.
     */
    dirty?: boolean;

    /**
     * A generic error for the entire form given by the _error key in the
     * result from the synchronous validation function, the asynchronous
     * validation, or the rejected promise from onSubmit.
     */
    error?: string;

    /**
     * The form name that you gave to the reduxForm() decorator or the prop you
     * passed in to your decorated form component.
     */
    form?: string;

    /**
     * A function meant to be passed to <form onSubmit={handleSubmit}> or to
     * <button onClick={handleSubmit}>. It will run validation, both sync and
     * async, and, if the form is valid, it will call
     * this.props.onSubmit(data) with the contents of the form data.
     *
     * Optionally, you may also pass your onSubmit function to handleSubmit
     * which will take the place of the onSubmit prop. For example: <form
     * onSubmit={handleSubmit(this.save.bind(this))}>
     *
     * If your onSubmit function returns a promise, the submitting property
     * will be set to true until the promise has been resolved or rejected.
     * If it is rejected with an object like
     * new SubmissionError({ field1: 'error', field2: 'error' })
     * then the submission errors will be added to each field (to the error
     * prop) just like async validation errors are. If there is an error that
     * is not specific to any field, but applicable to the entire form, you
     * may pass that as if it were the error for a field called _error, and
     * it will be given as the error prop.
     */
    handleSubmit?(event: SyntheticEvent<any>): void; // same as ReactEventHandler

    handleSubmit?(submit: SubmitHandler<FormData, P, S>): ReactEventHandler<any>;

    /**
     * Initializes the form data to the given values. All dirty and pristine
     * state will be determined by comparing the current data with these
     * initialized values.
     */
    initialize?(data: FormData): void;

    /**
     * true if the form has validation errors. Opposite of valid.
     */
    invalid?: boolean;

    /**
     * true if the form data is the same as its initialized values. Opposite
     * of dirty.
     */
    pristine?: boolean;

    /**
     * Resets all the values in the form to the initialized state, making it
     * pristine again.
     */
    reset?(): void;

    /**
     * Whether or not your form is currently submitting. This prop will only
     * work if you have passed an onSubmit function that returns a promise. It
     * will be true until the promise is resolved or rejected.
     */
    submitting?: boolean;

    /**
     * Starts as false. If onSubmit is called, and fails to submit for any
     * reason, submitFailed will be set to true. A subsequent successful
     * submit will set it back to false.
     */
    submitFailed?: boolean;

    /**
     * Starts as false. If onSubmit is called, and succeed to submit,
     * submitSucceeded will be set to true. A subsequent unsuccessful
     * submit will set it back to false.
     */
    submitSucceeded?: boolean;

    /**
     * Marks the given fields as "touched" to show errors.
     */
    touch?(...field: string[]): void;

    /**
     * Clears the "touched" flag for the given fields
     */
    untouch?(...field: string[]): void;

    /**
     * true if the form passes validation (has no validation errors). Opposite
     * of invalid.
     */
    valid?: boolean;

    /**
     * A generic warning for the entire form given by the `_warning` key in the result from the
     * synchronous warning function.
     */
    warning?: string;
}
}
declare module 'redux-form/lib/reduxForm' {
export * from '~redux-form/lib/reduxForm';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/7aaf957deb409060efc12dcafa001708f677cbb5/redux-form/lib/Field.d.ts
declare module '~redux-form/lib/Field' {
import {
    Component,
    ReactElement,
    DragEventHandler,
    FocusEventHandler,
    FormEventHandler,
} from 'react';
import { Dispatch } from 'redux';
import { ComponentConstructor, DataShape, FieldValue } from '~redux-form/index';

/**
 * These are the props to give to `Field`.
 * Any others will be passed through to your component.
 */
interface BaseFieldProps {
    /**
     * A string path, in dot-and-bracket notation, corresponding to a value
     * in the form values. It may be as simple as 'firstName' or as complicated
     * as contact.billing.address[2].phones[1].areaCode.
     *
     * Required but made optional so interface can be used on decorated components.
     */
    name?: string;

    /**
     * A Component, stateless function, or string corresponding to a default
     * JSX element.
     *
     * Required but made optional so interface can be used on decorated components.
     */
    component?: ComponentConstructor | "input" | "select" | "textarea",
    // component?: ComponentClass<P> | SFC<P> | "input" | "select" | "textarea",

    /**
     * If true, the rendered component will be available with the
     * getRenderedComponent() method. Defaults to false. Cannot be used if your
     * component is a stateless function component.
     */
    withRef?: boolean;

    /**
     * Formats the value from the Redux store to be displayed in the field input.
     * Common use cases are to format Numbers into currencies or Dates into a
     * localized date format.
     */
    format?: Formatter | null;

    /**
     * A function to convert whatever value the user has entered into the value that you
     * want stored in the Redux store for the field.
     *
     * For instance, if you want the value to be in all uppercase, you would pass
     *   value => value.toUpperCase()
     */
    normalize?: Normalizer;

    /**
     * Don't use.
     */
    props?: Object;

    /**
     * Parses the value given from the field input component to the type that you want
     * stored in the Redux store. Common use cases are to parse currencies into Numbers into
     * currencies or localized date formats into Dates.
     */
    parse?: Parser;

    /**
     * Allows you to to provide a field-level validation rule. The function will be given the
     * current value of the field and all the other form values. If the field is valid, it
     * should return `undefined`, if the field is invalid, it should return an error
     * (usually, but not necessarily, a `String`).
     */
    validate?: Validator|Validator[];

    /**
     * Allows you to to provide a field-level warning rule. The function will be given the
     * current value of the field and all the other form values. If the field needs a warning,
     * it should return the warning (usually, but not necessarily, a `String`). If the field
     * does not need a warning, it should return `undefined`.
     */
    warn?: Validator|Validator[];
}

/**
 * @param value             The value entered by the user.
 * @param previousValue     The previous value for the field.
 * @param allValues         All the values in the entire form with the new value.
 *                          This will be an Immutable Map if you are using Immutable JS.
 * @param previousAllValues All the values in the entire form before the current change.
 *                          This will be an Immutable Map if you are using Immutable JS.
 */
export type Normalizer = (value: FieldValue, previousValue?: FieldValue, allValues?: Object, previousAllValues?: Object) => FieldValue;

export type Formatter = (value: FieldValue, name: string) => FieldValue;

export type Parser = (value: FieldValue, name: string) => FieldValue;

export type Validator = (value: FieldValue, allValues?: Object) => undefined | string;

/**
 * Declare Field as this interface to specify the generic.
 */
export interface GenericField<FieldCustomProps, S> extends Component<BaseFieldProps & FieldCustomProps, {}> {
    /**
     * true if the current value is different from the initialized value,
     * false otherwise.
     */
    dirty: boolean;

    /**
     * The name prop that you passed in.
     */
    name: string;

    /**
     * true if the current value is the same as the initialized value,
     * false otherwise.
     */
    pristine: boolean;

    /**
     * The current value of the field.
     */
    value: FieldValue;

    /**
     * Returns the instance of the rendered component. For this to work, you must
     * provide a withRef prop, and your component must not be a stateless function
     * component.
     */
    getRenderedComponent(): Component<WrappedFieldProps<S> & FieldCustomProps, any>;
}

/**
 * The Field Instance API.
 */
export class Field extends Component<any, {}> implements GenericField<any, any> {
    /**
     * true if the current value is different from the initialized value,
     * false otherwise.
     */
    dirty: boolean;

    /**
     * The name prop that you passed in.
     */
    name: string;

    /**
     * true if the current value is the same as the initialized value,
     * false otherwise.
     */
    pristine: boolean;

    /**
     * The current value of the field.
     */
    value: FieldValue;

    /**
     * Returns the instance of the rendered component. For this to work, you must
     * provide a withRef prop, and your component must not be a stateless function
     * component.
     */
    getRenderedComponent(): Component<any, any>;
}

/**
 * These are props that `Field` will pass to your wrapped component (not including custom props).
 */
interface WrappedFieldProps<S> {
    /**
     * An object containing all the props that you will normally want to pass to
     * your input component.
     */
    input: WrappedFieldInputProps;

    /**
     * An object containing all the metadata props.
     */
    meta: WrappedFieldMetaProps<S>;
}

/**
 * These props are meant to be destructured into your <input/> component.
 */
interface WrappedFieldInputProps {
    /**
     * An alias for value only when value is a boolean. Provided for
     * convenience of destructuring the whole field object into the props of a
     * form element.
     */
    checked?: boolean;

    /**
     * The name prop passed in.
     */
    name: string;

    /**
     * A function to call when the form field loses focus.
     */
    onBlur: FocusEventHandler<any>;

    /**
     * A function to call when the form field is changed.
     */
    onChange: FormEventHandler<any>;

    /**
     * A function to call when the form field receives a 'dragStart' event.
     * Saves the field value in the event for giving the field it is dropped
     * into.
     */
    onDragStart: DragEventHandler<any>;

    /**
     * A function to call when the form field receives a drop event.
     */
    onDrop: DragEventHandler<any>;

    /**
     * A function to call when the form field receives focus.
     */
    onFocus: FocusEventHandler<any>;

    /**
     * The value of this form field. It will be a boolean for checkboxes, and
     * a string for all other input types. If there is no value in the Redux
     * state for this field, it will default to ''. This is to
     * ensure that the input is controlled.
     */
    value: FieldValue;
}

/**
 * These props are metadata about the state of this field that redux-form is tracking for you.
 */
interface WrappedFieldMetaProps<S> {

    /**
     * true if this field currently has focus. It will only work if you are
     * passing onFocus to your input element.
     */
    active?: boolean;

    /**
     * true if this field has been set with the AUTOFILL action and has not since been changed
     * with a CHANGE action. This is useful to render the field in a way that the user can tell
     * that the value was autofilled for them.
     */
    autofilled: boolean;

    /**
     * true if the form is currently running asynchronous validation because this
     * field was blurred.
     */
    asyncValidating: boolean;

    /**
     * true if the field value has changed from its initialized value.
     * Opposite of pristine.
     */
    dirty: boolean;

    /**
     * The Redux dispatch function.
     */
    dispatch: Dispatch<S>;

    /**
     * The error for this field if its value is not passing validation. Both
     * synchronous, asynchronous, and submit validation errors will be reported here.
     */
    error?: string;

    /**
     * true if the field value fails validation (has a validation error).
     * Opposite of valid.
     */
    invalid: boolean;

    /**
     * true if the field value is the same as its initialized value. Opposite
     * of dirty.
     */
    pristine: boolean;

    /**
     * true if the field has been touched. By default this will be set when
     * the field is blurred.
     */
    touched: boolean;

    /**
     * true if the field value passes validation (has no validation errors).
     * Opposite of invalid.
     */
    valid: boolean;

    /**
     * true if this field has ever had focus. It will only work if you are
     * passing onFocus to your input element.
     */
    visited?: boolean;

    /**
     * The warning for this field if its value is not passing warning validation.
     */
    warning?: string;
}
}
declare module 'redux-form/lib/Field' {
export * from '~redux-form/lib/Field';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/7aaf957deb409060efc12dcafa001708f677cbb5/redux-form/lib/Fields.d.ts
declare module '~redux-form/lib/Fields' {
import { Component } from 'react';
import { ComponentConstructor, Formatter, Parser, FieldValue } from '~redux-form/index';

/**
 * These are the props to give to `Field`.
 * Any others will be passed through to your component.
 */
interface BaseFieldsProps {
    /**
     * An array of strings (or the pseudo-array fields provided by FieldArray),
     * in dot-and-bracket notation, corresponding to form values.
     * They may be as simple as 'firstName' or as complicated as
     * 'contact.billing.address[2].phones[1].areaCode'.
     */
    names: string[];

    /**
     * A Component or stateless function that will be given all the props necessary
     * to render the field inputs.
     */
    component?: ComponentConstructor | 'input' | 'select' | 'textarea';

    /**
     * Formats the value from the Redux store to be displayed in the field input.
     * Common use cases are to format Numbers into currencies or Dates into a localized date format.
     *
     * format is called with the field value and name as arguments and should return the new formatted
     * value to be displayed in the field input.
     *
     * To respect React 15 input behavior there is defaultFormat = value => value == null ? '' : value
     * internally used. To disable that you can pass null as format prop.
     */
    format?: Formatter | null;

    /**
     * Don't use.
     */
    props?: Object;

    /**
     * Parses the value given from the field input component to the type that you want stored in the Redux store.
     * Common use cases are to parse currencies into Numbers into currencies or localized date formats into Dates.
     *
     * parse is called with the field value and name as arguments and should return the new parsed value to be
     * stored in the Redux store.
     */
    parse?: Parser;

    /**
     * If true, the rendered component will be available with the getRenderedComponent() method.
     * Defaults to false. Cannot be used if your component is a stateless function component.
     */
    withRef?: boolean;
}

/**
 * Declare Fields as this interface to specify the generics.
 */
export interface GenericFields<T, FieldsCustomProps> extends Component<BaseFieldsProps & FieldsCustomProps, {}> {
    /**
     * true if the current value of any of the fields is different from the initialized value, false otherwise.
     */
    dirty: boolean;

    /**
     * The names prop that you passed in.
     */
    names: string[];

    /**
     * true if the all of the current values are the same as the initialized values, false otherwise.
     */
    pristine: boolean;

    /**
     * The current values of the fields. If they are nested, the values will duplicate the structure.
     * For example, if your names are [ 'name.first', 'name.last', 'email' ], the values will be
     * { name: { first: 'John', last: 'Smith' }, email: 'john@email.com' }
     */
    values: {[name: string]: FieldValue};

    getRenderedComponent(): Component<BaseFieldsProps & FieldsCustomProps, any>;
}

/**
 * The Fields Instance API.
 */
export class Fields extends Component<any, {}> implements GenericFields<any, any> {
    /**
     * true if the current value of any of the fields is different from the initialized value, false otherwise.
     */
    dirty: boolean;

    /**
     * The names prop that you passed in.
     */
    names: string[];

    /**
     * true if the all of the current values are the same as the initialized values, false otherwise.
     */
    pristine: boolean;

    /**
     * The current values of the fields. If they are nested, the values will duplicate the structure.
     * For example, if your names are [ 'name.first', 'name.last', 'email' ], the values will be
     * { name: { first: 'John', last: 'Smith' }, email: 'john@email.com' }
     */
    values: {[name: string]: FieldValue};

    getRenderedComponent(): Component<any, any>;
}
}
declare module 'redux-form/lib/Fields' {
export * from '~redux-form/lib/Fields';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/7aaf957deb409060efc12dcafa001708f677cbb5/redux-form/lib/FieldArray.d.ts
declare module '~redux-form/lib/FieldArray' {
import { Component } from 'react';
import { ComponentConstructor, Validator } from '~redux-form/index';

/**
 * These are the props to give to `FieldArray`.
 * Any others will be passed through to your component.
 */
interface BaseFieldArrayProps {
    /**
     * A string path, in dot-and-bracket notation, corresponding to a value
     * in the form values. It may be as simple as 'firstName' or as complicated
     * as contact.billing.address[2].phones[1].areaCode.
     *
     * Required but made optional so interface can be used on decorated components.
     */
    name?: string;

    /**
     * A Component or stateless function to render the field array.
     *
     * Required but made optional so interface can be used on decorated components.
     */
    component?: ComponentConstructor,
    // component?: Component<P, any> | StatelessComponent<P>,

    /**
     * Allows you to to provide a field-level validation rule. The function will be given the
     * current value of the field and all the other form values. If the field is valid, it
     * should return `undefined`, if the field is invalid, it should return an error
     * (usually, but not necessarily, a `String`).
     */
    validate?: Validator|Validator[];

    /**
     * Allows you to to provide a field-level warning rule. The function will be given the
     * current value of the field and all the other form values. If the field needs a warning,
     * it should return the warning (usually, but not necessarily, a `String`). If the field
     * does not need a warning, it should return `undefined`.
     */
    warn?: Validator|Validator[];

    /**
     * If true, the rendered component will be available with the
     * getRenderedComponent() method. Defaults to false. Cannot be used if your
     * component is a stateless function component.
     */
    withRef?: boolean;

    props?: Object;
}

/**
 * Declare FieldArray as this interface to specify the generics.
 */
export interface GenericFieldArray<T, FieldCustomProps> extends Component<BaseFieldArrayProps & FieldCustomProps, {}> {

    /**
     * The name prop that you passed in.
     */
    name: string;

    /**
     * true if this field passes validation, false otherwise.
     */
    valid: boolean;

    /**
     * Returns the instance of the rendered component. For this to work, you must
     * provide a withRef prop, and your component must not be a stateless function
     * component.
     */
    getRenderedComponent(): Component<WrappedFieldArrayProps<T> & FieldCustomProps, any>;
}

/**
 * The FieldArray Instance API.
 */
export class FieldArray extends Component<any, {}> implements GenericFieldArray<any, any> {

    /**
     * The name prop that you passed in.
     */
    name: string;

    /**
     * true if this field passes validation, false otherwise.
     */
    valid: boolean;

    /**
     * Returns the instance of the rendered component. For this to work, you must
     * provide a withRef prop, and your component must not be a stateless function
     * component.
     */
    getRenderedComponent(): Component<any, any>;
}

/**
 * These are props that `FieldArray` will pass to your wrapped component.
 */
interface WrappedFieldArrayProps<T> {
    fields: FieldsProps<T>;

    meta: FieldArrayMetaProps;
}

interface FieldsProps<T> {
    /**
     * A method to iterate over each value of the array.
     */
    forEach(callback: (name: string, index: number, fields: FieldsProps<T>) => void): void;

    /**
     * A method to get a single value from the array value.
     */
    get(index: number): T;

    /**
     * A method to get all the values in the array.
     */
    getAll(): T[];

    /**
     * A function to insert a new value into the array at any arbitrary index.
     */
    insert(index: number, value: T): void;

    /**
     * The current length of the array.
     */
    length: number;

    /**
     * A method to iterate over each value of the array. Returns an array of the
     * results of each call to the callback.
     */
    map(callback: (name: string, index: number, fields: FieldsProps<T>) => any): any;

    /**
     * Removes an item from the end of the array. Returns the item removed.
     */
    pop(): T;

    /**
     * Adds a value to the end of the array.
     */
    push(value: T): void;

    /**
     * Removes an item from the array at an arbitrary index.
     */
    remove(index: number): void;

    /**
     * Removes an item from beginning of the array. Returns the item removed.
     */
    shift(): T;

    /**
     * Swaps two items in the array at the given indexes.
     */
    swap(indexA: number, indexB: number): void;

    /**
     * Adds an item to the beginning of the array.
     */
    unshift(value: T): void;
}

interface FieldArrayMetaProps {
    /**
     * true if the any of the fields in the field array have changed from their
     * initialized value. Opposite of pristine.
     */
    dirty: boolean;

    /**
     * The error for this field array if its value is not passing validation. Both
     * synchronous, asynchronous, and submit validation errors will be reported here.
     * Array-specific errors should be returned from the validation function as an
     * _error key on the array.
     */
    error?: string;

    /**
     * true if the field array value fails validation (has a validation error).
     * Opposite of valid.
     */
    invalid: boolean;

    /**
     * true if the all of the fields in the field array are the same as their
     * initialized value. Opposite of dirty.
     */
    pristine: boolean;

    /**
     * true if any of the fields have been touched.
     */
    touched: boolean;

    /**
     * true if the field value passes validation (has no validation errors).
     * Opposite of invalid.
     */
    valid: boolean;

    /**
     * The warning for this field array if its values are not passing warning validation.
     * Array-specific errors should be returned from the validation function as an
     * `_warning` key on the array.
     */
    warning?: string;
}
}
declare module 'redux-form/lib/FieldArray' {
export * from '~redux-form/lib/FieldArray';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/7aaf957deb409060efc12dcafa001708f677cbb5/redux-form/lib/FormSection.d.ts
declare module '~redux-form/lib/FormSection' {
import { Component } from 'react';

interface FormSectionProps {
    /**
     * The name all child fields should be prefixed with.
     */
    name: string;
}

/**
 * The FormSection component makes it easy to split forms into smaller components that are resuable across
 * multiple forms. It does this by prefixing the name of Field, Fields and FieldArray children, at any depth,
 * with the value specified in the name prop.
 */
export class FormSection extends Component<FormSectionProps, any> {

}
}
declare module 'redux-form/lib/FormSection' {
export * from '~redux-form/lib/FormSection';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/7aaf957deb409060efc12dcafa001708f677cbb5/redux-form/lib/actions.d.ts
declare module '~redux-form/lib/actions' {
import { Action } from 'redux';
import { FormErrors, FormWarnings, FieldType } from '~redux-form/index';

/**
 * Inserts an item into a field array at the specified index
 */
export function arrayInsert(form: string, field: string, index: number, value: any): Action;

/**
 * Moves an item from one index in the array to another. In effect, it performs a remove and an
 * insert, so the item already at the `to` position will be bumped to a higher index, not overwritten.
 */
export function arrayMove(form: string, field: string, from: number, to: number): Action;

/**
 * Removes an item from the end of a field array
 */
export function arrayPop(form: string, field: string): Action;

/**
 * Appends an item to the end of a field array
 */
export function arrayPush(form: string, field: string, value: any): Action;

/**
 * Removes an item at the specified index from a field array
 */
export function arrayRemove(form: string, field: string, index: number): Action;

/**
 * Removes all items from a field array
 */
export function arrayRemoveAll(form: string, field: string): Action;

/**
 * Removes an item from the beginning of a field array
 */
export function arrayShift(form: string, field: string): Action;

/**
 * ADVANCED USAGE - Inserts and/or removes items from a field array. Works similarly to Array.splice.
 */
export function arraySplice(form: string, field: string, index: number, removeNum: number, value: any): Action;

/**
 * Swaps two items at the specified indexes in a field array
 */
export function arraySwap(form: string, field: string, indexA: number, indexB: number): Action;

/**
 * Inserts an item at the beginning of a field array
 */
export function arrayUnshift(form: string, field: string, value: any): Action;

/**
 * Saves the value to the field and sets its `autofilled` property to `true`.
 */
export function autofill(form: string, field: string, value: any): Action;

/**
 * Saves the value to the field
 */
export function blur(form: string, field: string, value: any): Action;

/**
 * Saves the value to the field
 */
export function change(form: string, field: string, value: any): Action;

/**
 * Destroys the form, removing all it's state
 */
export function destroy(form: string): Action;

/**
 * Marks the given field as active and visited
 */
export function focus(form: string, field: string): Action;

/**
 * Sets the initial values in the form with which future data values will be compared to calculate dirty and pristine.
 * The data parameter may contain deep nested array and object values that match the shape of your form fields.
 * If the keepDirty parameter is true, the values of the currently dirty fields will be retained to avoid overwriting
 * user edits.
 */
export function initialize(form: string, data: Object, keepDirty: boolean): Action;

/**
 * Registers a field with the form.
 */
export function registerField(form: string, name: string, type: FieldType): Action;

/**
 * Resets the values in the form back to the values past in with the most recent initialize action.
 */
export function reset(form: string): Action;

/**
 * Flips the asyncValidating flag true
 */
export function startAsyncValidation(form: string): Action;

/**
 * Flips the submitting flag true.
 */
export function startSubmit(form: string): Action;

/**
 * Flips the submitting flag false and populates submitError for each field.
 */
export function stopSubmit(form: string, errors?: Object): Action;

/**
 * Flips the asyncValidating flag false and populates asyncError for each field.
 */
export function stopAsyncValidation(form: string, errors?: Object): Action;

export function setSubmitFailed(form: string, ...fields: string[]): Action;

export function setSubmitSucceeded(form: string, ...fields: string[]): Action;

/**
 * Triggers a submission of the specified form.
 */
export function submit(form: string): Action;

/**
 * Marks all the fields passed in as touched.
 */
export function touch(form: string, ...fields: string[]): Action;

/**
 * Unregisters a field with the form.
 */
export function unregisterField(form: string, name: string): Action;

/**
 * Resets the 'touched' flag for all the fields passed in.
 */
export function untouch(form: string, ...fields: string[]): Action;

export function updateSyncErrors(from: string, syncErrors: FormErrors<FormData>, error: any): Action;

export function updateSyncWarnings(form: string, syncWarnings: FormWarnings<FormData>, warning: any): Action;
}
declare module 'redux-form/lib/actions' {
export * from '~redux-form/lib/actions';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/7aaf957deb409060efc12dcafa001708f677cbb5/redux-form/lib/reducer.d.ts
declare module '~redux-form/lib/reducer' {
import { Action, Reducer } from 'redux';
import { FieldType } from '~redux-form/index';

export function reducer(state: FormStateMap, action: Action): FormStateMap & FormReducer;

export interface FormReducer {
    /**
     * Returns a form reducer that will also pass each action through
     * additional reducers specified. The parameter should be an object mapping
     * from formName to a (state, action) => nextState reducer. The state
     * passed to each reducer will only be the slice that pertains to that
     * form.
     */
    plugin(reducers: FormReducerMapObject): Reducer<any>;
}

export interface FormReducerMapObject {
    [formName: string]: Reducer<any>;
}

/**
 * Store state
 */

export interface FormStateMap {
    [formName: string]: FormState;
}

export interface FormState {
    registeredFields: RegisteredFieldState[];
    fields?: {[name: string]: FieldState};
    values?: { [fieldName: string]: string };
    active?: string;
    anyTouched?: boolean;
    submitting?: boolean;
    submitErrors?: { [fieldName: string]: string };
    submitFailed?: boolean;
}

export interface RegisteredFieldState {
    name: string;
    type: FieldType;
}

export interface FieldState {
    active?: boolean;
    touched?: boolean;
    visited?: boolean;
}
}
declare module 'redux-form/lib/reducer' {
export * from '~redux-form/lib/reducer';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/7aaf957deb409060efc12dcafa001708f677cbb5/redux-form/lib/selectors.d.ts
declare module '~redux-form/lib/selectors' {
import { DataShape, FormErrors } from '~redux-form/index';

/**
 * A "selector" API to make it easier to connect() to form values. Creates a selector
 * function for your form that can be used with your field names.
 */
export function formValueSelector<State>(form: string, getFormState?: () => State): Selector<State>;

export interface Selector<State> {
    (state: State, ...field: string[]): Object
}

/**
 * Gets form data.
 */
export interface DataSelector {
    <FormData extends DataShape, State>(formName: string): (state: State) => FormData;
    <FormData extends DataShape>(formName: string): (state: any) => FormData;
}

/**
 * Gets form errors.
 */
export interface ErrorSelector {
    <FormData extends DataShape, State>(formName: string): (state: State) => FormErrors<FormData>;
    <FormData extends DataShape>(formName: string): (state: any) => FormErrors<FormData>;
}

/**
 * Gets boolean info from form.
 */
export interface BooleanSelector {
    <State>(formName: string): (state: State) => boolean;
    (formName: string): (state: any) => boolean;
}

/**
 * Gets the form values. Shocking, right?
 */
export const getFormValues: DataSelector;

/**
 * Returns the form synchronous validation errors.
 */
export const getFormSyncErrors: ErrorSelector;

/**
 * Returns the form submit validation errors.
 */
export const getFormSubmitErrors: ErrorSelector;

/**
 * Returns true if the form is dirty, i.e. the values have been altered
 * from the original initialValues provided. The opposite of isPristine.
 */
export const isDirty: BooleanSelector;

/**
 * Returns true if the form is pristine, i.e. the values have NOT been altered
 * from the original initialValues provided. The opposite of isDirty.
 */
export const isPristine: BooleanSelector;

/**
 * Returns true if the form is valid, i.e. has no sync, async, or submission
 * errors. The opposite of isInvalid.
 */
export const isValid: BooleanSelector;

/**
 * Returns true if the form is invalid, i.e. has sync, async, or submission
 * errors. The opposite of isValid.
 */
export const isInvalid: BooleanSelector;
}
declare module 'redux-form/lib/selectors' {
export * from '~redux-form/lib/selectors';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/7aaf957deb409060efc12dcafa001708f677cbb5/redux-form/index.d.ts
declare module '~redux-form/index' {
// Type definitions for redux-form v6.3.3
// Project: https://github.com/erikras/redux-form
// Definitions by: Carson Full <https://github.com/carsonf>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
// TypeScript Version: 2.1

///<reference types="react" />

import {
  ComponentClass,
  StatelessComponent,
} from 'react';

export type FieldValue = any;

export type FieldType = 'Field' | 'FieldArray';

export type DataShape = {[fieldName:string]: FieldValue};

export type FormErrors<FormData extends DataShape> = {
    [P in keyof FormData]?: React.ReactElement<any> | string | { _error?: string };
};

export type FormWarnings<FormData extends DataShape> = {
  [P in keyof FormData]?: React.ReactElement<any> | string;
} & { _warning?: string };

/**
 * A component class or stateless function component.
 * Workaround for: ComponentClass<P> | SFC<P> which does
 * not resolve due to a bug in TypeScript.
 * https://github.com/Microsoft/TypeScript/pull/8674
 */
export type ComponentConstructor = ComponentClass<any> | StatelessComponent<any>;

export * from '~redux-form/lib/reduxForm';
export * from '~redux-form/lib/Field';
export * from '~redux-form/lib/Fields';
export * from '~redux-form/lib/FieldArray';
export * from '~redux-form/lib/FormSection';
export * from '~redux-form/lib/actions';
export * from '~redux-form/lib/reducer';
export * from '~redux-form/lib/selectors';
}
declare module 'redux-form/index' {
export * from '~redux-form/index';
}
declare module 'redux-form' {
export * from '~redux-form/index';
}
